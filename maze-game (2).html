<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ± ë¯¸ë¡œ íƒˆì¶œ ê²Œì„ ğŸ§€</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        .game-container {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #764ba2;
            margin: 0 0 20px 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .info {
            text-align: center;
            font-size: 1.2em;
            color: #555;
            margin-bottom: 20px;
        }

        .controls {
            text-align: center;
            margin-bottom: 15px;
            color: #666;
            font-size: 0.9em;
        }

        canvas {
            border: 4px solid #764ba2;
            border-radius: 10px;
            display: block;
            margin: 0 auto;
            background: #f0f0f0;
        }

        .level-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
            -webkit-tap-highlight-color: rgba(0,0,0,0.2);
            touch-action: manipulation;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(118, 75, 162, 0.4);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(118, 75, 162, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .controls-overlay {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
        }

        .dpad {
            position: relative;
            width: 150px;
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 5px;
        }

        .dpad-button {
            background: rgba(102, 126, 234, 0.8);
            border: 2px solid #667eea;
            border-radius: 10px;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s;
        }

        .dpad-button:active {
            background: rgba(118, 75, 162, 0.9);
            transform: scale(0.95);
        }

        .dpad-center {
            background: transparent;
            border: none;
            pointer-events: none;
        }

        .dpad-up { grid-column: 2; grid-row: 1; }
        .dpad-left { grid-column: 1; grid-row: 2; }
        .dpad-center { grid-column: 2; grid-row: 2; }
        .dpad-right { grid-column: 3; grid-row: 2; }
        .dpad-down { grid-column: 2; grid-row: 3; }

        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .level-buttons {
                flex-wrap: wrap;
            }

            button {
                padding: 10px 15px;
                font-size: 0.9em;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }

        @media (min-width: 769px) {
            .controls-overlay {
                display: none;
            }
        }

        .congratulations {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            text-align: center;
            display: none;
            z-index: 1000;
            animation: popup 0.5s ease-out;
        }

        @keyframes popup {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .congratulations h2 {
            color: #667eea;
            font-size: 2.5em;
            margin: 0 0 20px 0;
        }

        .congratulations p {
            font-size: 1.3em;
            color: #666;
            margin-bottom: 20px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            z-index: 999;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1001;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ± ë¯¸ë¡œ íƒˆì¶œ ê²Œì„ ğŸ§€</h1>
        <div class="info">
            <div>ë ˆë²¨: <span id="level">1</span> | ì›€ì§ì„: <span id="moves">0</span></div>
            <div id="pathInfo" style="margin-top: 5px; font-size: 0.9em; color: #666;"></div>
            <div id="hintInfo" style="margin-top: 5px; font-size: 0.9em; color: #666;"></div>
        </div>
        <div class="controls">
            â¬†ï¸â¬‡ï¸â¬…ï¸â¡ï¸ í™”ì‚´í‘œ í‚¤ë¡œ ê³ ì–‘ì´ë¥¼ ì›€ì§ì—¬ ì¹˜ì¦ˆë¥¼ ì°¾ìœ¼ì„¸ìš”!
        </div>
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        <div class="level-buttons">
            <button ontouchstart="this.click(); event.preventDefault();" onclick="loadLevel(3)">ë ˆë²¨ 3 (ì¼ë°˜)</button>
            <button ontouchstart="this.click(); event.preventDefault();" onclick="loadLevel(4)">ë ˆë²¨ 4 (ì–´ë‘  ëª¨ë“œ ğŸŒ™)</button>
            <button ontouchstart="this.click(); event.preventDefault();" onclick="loadLevel(5)">ë ˆë²¨ 5 (ìŠˆí¼ ë‚œì´ë„ ğŸ”¥)</button>
            <button ontouchstart="this.click(); event.preventDefault();" onclick="loadLevel(6)">ë ˆë²¨ 6 (ê·¹í•œ ë‚œì´ë„ ğŸ’€)</button>
            <button ontouchstart="this.click(); event.preventDefault();" onclick="loadLevel(7)">ë ˆë²¨ 7 (ë¶ˆê°€ëŠ¥ ëª¨ë“œ â˜ ï¸)</button>
            <button ontouchstart="this.click(); event.preventDefault();" onclick="restartLevel()">ìƒˆ ë¯¸ë¡œ ìƒì„±</button>
            <button id="hintBtn" ontouchstart="this.click(); event.preventDefault();" onclick="useHint()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">ğŸ’¡ íŒíŠ¸</button>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <p>ë¯¸ë¡œ ìƒì„± ì¤‘...</p>
    </div>
    
    <div class="congratulations" id="congratulations">
        <h2>ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰</h2>
        <p>ë¯¸ë¡œë¥¼ ì„±ê³µì ìœ¼ë¡œ íƒˆì¶œí–ˆì–´ìš”!</p>
        <p>ì›€ì§ì„: <span id="finalMoves">0</span>ë²ˆ</p>
        <p id="finalHintInfo" style="font-size: 0.9em;"></p>
        <p id="finalPathInfo" style="font-size: 0.9em; color: #666;"></p>
        <button ontouchstart="this.click(); event.preventDefault();" onclick="nextLevel()">ë‹¤ìŒ ë ˆë²¨</button>
        <button ontouchstart="this.click(); event.preventDefault();" onclick="restartLevel()">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>

    <!-- ëª¨ë°”ì¼ ë°©í–¥í‚¤ ì»¨íŠ¸ë¡¤ -->
    <div class="controls-overlay">
        <div class="dpad">
            <div class="dpad-button dpad-up" ontouchstart="handleDpadTouch(event, 0, -1)" ontouchend="event.preventDefault()">â¬†ï¸</div>
            <div class="dpad-button dpad-left" ontouchstart="handleDpadTouch(event, -1, 0)" ontouchend="event.preventDefault()">â¬…ï¸</div>
            <div class="dpad-center"></div>
            <div class="dpad-button dpad-right" ontouchstart="handleDpadTouch(event, 1, 0)" ontouchend="event.preventDefault()">â¡ï¸</div>
            <div class="dpad-button dpad-down" ontouchstart="handleDpadTouch(event, 0, 1)" ontouchend="event.preventDefault()">â¬‡ï¸</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let cellSize = 25;
        let gridSize = 20;
        
        let player = { x: 0, y: 0 };
        let goal = { x: 19, y: 19 };
        let moves = 0;
        let currentLevel = 3;
        let maze = [];
        let hintActive = false;
        let hintCooldown = false;
        let hintsRemaining = 0;
        let hintsUsed = 0;
        let shortestPathLength = 0;
        
        // BFSë¡œ ê²½ë¡œ ì¡´ì¬ ì—¬ë¶€ ë° ìµœë‹¨ ê±°ë¦¬ í™•ì¸
        function findShortestPath(startX, startY, goalX, goalY) {
            const visited = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
            const queue = [[startX, startY, 0]]; // x, y, distance
            visited[startY][startX] = true;
            
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            
            while (queue.length > 0) {
                const [x, y, dist] = queue.shift();
                
                // ëª©í‘œ ì§€ì  ë„ë‹¬
                if (x === goalX && y === goalY) {
                    return dist;
                }
                
                // 4ë°©í–¥ íƒìƒ‰
                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (newX >= 0 && newX < gridSize && 
                        newY >= 0 && newY < gridSize && 
                        maze[newY][newX] === 0 && 
                        !visited[newY][newX]) {
                        visited[newY][newX] = true;
                        queue.push([newX, newY, dist + 1]);
                    }
                }
            }
            
            return -1; // ê²½ë¡œ ì—†ìŒ
        }
        
        // ëœë¤í•œ ë¹ˆ ê³µê°„ ì°¾ê¸°
        function findRandomEmptyCell() {
            const emptyCells = [];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (maze[y][x] === 0) {
                        emptyCells.push([x, y]);
                    }
                }
            }
            if (emptyCells.length === 0) return null;
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
        }
        
        // ëœë¤ ë¯¸ë¡œ ìƒì„± (DFS ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©)
        function generateMaze() {
            let attempts = 0;
            const maxAttempts = 200; // ì¶©ë¶„í•œ ì‹œë„ íšŸìˆ˜ë¡œ ë³µì›
            let minPathLength = 1;
            
            if (currentLevel === 5) {
                minPathLength = 120;
            } else if (currentLevel === 6) {
                minPathLength = 150;
            } else if (currentLevel === 7) {
                minPathLength = 180;
            }
            
            while (attempts < maxAttempts) {
                // ëª¨ë“  ì…€ì„ ë²½ìœ¼ë¡œ ì´ˆê¸°í™”
                maze = Array(gridSize).fill().map(() => Array(gridSize).fill(1));
                
                // DFSë¡œ ë¯¸ë¡œ ìƒì„±
                const stack = [];
                const startX = Math.floor(Math.random() * (gridSize / 2)) * 2;
                const startY = Math.floor(Math.random() * (gridSize / 2)) * 2;
                maze[startY][startX] = 0;
                stack.push([startX, startY]);
                
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                
                while (stack.length > 0) {
                    const [x, y] = stack[stack.length - 1];
                    
                    // ëœë¤í•˜ê²Œ ë°©í–¥ ì„ê¸°
                    const shuffledDirections = directions.sort(() => Math.random() - 0.5);
                    let moved = false;
                    
                    for (const [dx, dy] of shuffledDirections) {
                        const newX = x + dx;
                        const newY = y + dy;
                        
                        if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && maze[newY][newX] === 1) {
                            maze[newY][newX] = 0;
                            maze[y + dy/2][x + dx/2] = 0;
                            stack.push([newX, newY]);
                            moved = true;
                            break;
                        }
                    }
                    
                    if (!moved) {
                        stack.pop();
                    }
                }
                
                // ë ˆë²¨ 5, 6, 7: ëœë¤ ì‹œì‘/ë„ì°© ì§€ì 
                if (currentLevel >= 5) {
                    // ì¶”ê°€ ê²½ë¡œ ì„¤ì • (ì¡°ê±´ì„ ë§Œì¡±í•˜ê¸° ì‰½ê²Œ ì•½ê°„ ë§ì´)
                    let extraPaths = Math.floor(gridSize * 0.5);
                    if (currentLevel === 6) {
                        extraPaths = Math.floor(gridSize * 0.4);
                    } else if (currentLevel === 7) {
                        extraPaths = Math.floor(gridSize * 0.35);
                    }
                    
                    for (let i = 0; i < extraPaths; i++) {
                        const x = Math.floor(Math.random() * gridSize);
                        const y = Math.floor(Math.random() * gridSize);
                        if (x > 0 && x < gridSize - 1 && y > 0 && y < gridSize - 1) {
                            maze[y][x] = 0;
                        }
                    }
                    
                    // ëœë¤ ì‹œì‘/ë„ì°© ì§€ì  ì°¾ê¸°
                    const startPos = findRandomEmptyCell();
                    const goalPos = findRandomEmptyCell();
                    
                    if (!startPos || !goalPos) {
                        attempts++;
                        continue;
                    }
                    
                    const [startX, startY] = startPos;
                    const [goalX, goalY] = goalPos;
                    
                    // ê²½ë¡œ ê¸¸ì´ í™•ì¸
                    const pathLength = findShortestPath(startX, startY, goalX, goalY);
                    
                    // ë°˜ë“œì‹œ ê²½ë¡œê°€ ìˆì–´ì•¼ í•˜ê³ , ìµœì†Œ ê¸¸ì´ë„ ë§Œì¡±í•´ì•¼ í•¨
                    if (pathLength >= minPathLength) {
                        player.x = startX;
                        player.y = startY;
                        goal.x = goalX;
                        goal.y = goalY;
                        shortestPathLength = pathLength; // ìµœë‹¨ ê±°ë¦¬ ì €ì¥
                        console.log(`ìœ íš¨í•œ ë¯¸ë¡œ ìƒì„± ì™„ë£Œ! (ì‹œë„: ${attempts + 1}ë²ˆ, ìµœë‹¨ ê±°ë¦¬: ${pathLength}ì¹¸)`);
                        return;
                    }
                } else {
                    // ë ˆë²¨ 3, 4: ê³ ì • ì‹œì‘/ë„ì°© ì§€ì 
                    maze[0][0] = 0;
                    maze[gridSize-1][gridSize-1] = 0;
                    
                    // ì¶”ê°€ ê²½ë¡œë¥¼ ìµœì†Œí™” (gridSize * 0.3ë§Œ ì¶”ê°€)
                    for (let i = 0; i < Math.floor(gridSize * 0.3); i++) {
                        const x = Math.floor(Math.random() * gridSize);
                        const y = Math.floor(Math.random() * gridSize);
                        if ((x !== 0 || y !== 0) && (x !== gridSize-1 || y !== gridSize-1)) {
                            maze[y][x] = 0;
                        }
                    }
                    
                    // ê²½ë¡œê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                    const pathLength = findShortestPath(0, 0, gridSize - 1, gridSize - 1);
                    if (pathLength > 0) {
                        player.x = 0;
                        player.y = 0;
                        goal.x = gridSize - 1;
                        goal.y = gridSize - 1;
                        shortestPathLength = pathLength; // ìµœë‹¨ ê±°ë¦¬ ì €ì¥
                        console.log(`ìœ íš¨í•œ ë¯¸ë¡œ ìƒì„± ì™„ë£Œ! (ì‹œë„: ${attempts + 1}ë²ˆ, ìµœë‹¨ ê±°ë¦¬: ${pathLength}ì¹¸)`);
                        return;
                    }
                }
                
                attempts++;
            }
            
            // 200ë²ˆ ì‹œë„í•´ë„ ì•ˆë˜ë©´ ì¡°ê±´ì„ ì™„í™”í•´ì„œ ë‹¤ì‹œ ì‹œë„
            console.log('ì¡°ê±´ì„ ì™„í™”í•˜ì—¬ ì¬ì‹œë„...');
            attempts = 0;
            const relaxedMinPath = Math.floor(minPathLength * 0.7); // 30% ì™„í™”
            
            while (attempts < 100) {
                maze = Array(gridSize).fill().map(() => Array(gridSize).fill(1));
                
                const stack = [];
                const startX = Math.floor(Math.random() * (gridSize / 2)) * 2;
                const startY = Math.floor(Math.random() * (gridSize / 2)) * 2;
                maze[startY][startX] = 0;
                stack.push([startX, startY]);
                
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                
                while (stack.length > 0) {
                    const [x, y] = stack[stack.length - 1];
                    const shuffledDirections = directions.sort(() => Math.random() - 0.5);
                    let moved = false;
                    
                    for (const [dx, dy] of shuffledDirections) {
                        const newX = x + dx;
                        const newY = y + dy;
                        
                        if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && maze[newY][newX] === 1) {
                            maze[newY][newX] = 0;
                            maze[y + dy/2][x + dx/2] = 0;
                            stack.push([newX, newY]);
                            moved = true;
                            break;
                        }
                    }
                    
                    if (!moved) {
                        stack.pop();
                    }
                }
                
                if (currentLevel >= 5) {
                    // ë” ë§ì€ ì¶”ê°€ ê²½ë¡œ
                    const extraPaths = Math.floor(gridSize * 0.8);
                    for (let i = 0; i < extraPaths; i++) {
                        const x = Math.floor(Math.random() * gridSize);
                        const y = Math.floor(Math.random() * gridSize);
                        maze[y][x] = 0;
                    }
                    
                    const startPos = findRandomEmptyCell();
                    const goalPos = findRandomEmptyCell();
                    
                    if (startPos && goalPos) {
                        const [startX, startY] = startPos;
                        const [goalX, goalY] = goalPos;
                        const pathLength = findShortestPath(startX, startY, goalX, goalY);
                        
                        if (pathLength >= relaxedMinPath) {
                            player.x = startX;
                            player.y = startY;
                            goal.x = goalX;
                            goal.y = goalY;
                            shortestPathLength = pathLength; // ìµœë‹¨ ê±°ë¦¬ ì €ì¥
                            console.log(`ì™„í™”ëœ ì¡°ê±´ìœ¼ë¡œ ë¯¸ë¡œ ìƒì„± ì™„ë£Œ! (ìµœë‹¨ ê±°ë¦¬: ${pathLength}ì¹¸)`);
                            return;
                        }
                    }
                } else {
                    maze[0][0] = 0;
                    maze[gridSize-1][gridSize-1] = 0;
                    
                    for (let i = 0; i < Math.floor(gridSize * 0.5); i++) {
                        const x = Math.floor(Math.random() * gridSize);
                        const y = Math.floor(Math.random() * gridSize);
                        maze[y][x] = 0;
                    }
                    
                    const pathLength = findShortestPath(0, 0, gridSize - 1, gridSize - 1);
                    if (pathLength > 0) {
                        player.x = 0;
                        player.y = 0;
                        goal.x = gridSize - 1;
                        goal.y = gridSize - 1;
                        shortestPathLength = pathLength; // ìµœë‹¨ ê±°ë¦¬ ì €ì¥
                        console.log(`ì™„í™”ëœ ì¡°ê±´ìœ¼ë¡œ ë¯¸ë¡œ ìƒì„± ì™„ë£Œ! (ìµœë‹¨ ê±°ë¦¬: ${pathLength}ì¹¸)`);
                        return;
                    }
                }
                
                attempts++;
            }
            
            // ê·¸ë˜ë„ ì•ˆë˜ë©´ í™•ì‹¤íˆ í’€ ìˆ˜ ìˆëŠ” ê°„ë‹¨í•œ ë¯¸ë¡œ (í•˜ì§€ë§Œ ê²½ë¡œëŠ” ë³´ì¥)
            console.log('ê°„ë‹¨í•œ ë¯¸ë¡œ ìƒì„± (ê²½ë¡œ ë³´ì¥)');
            maze = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
            
            if (currentLevel >= 5) {
                // ëœë¤ ì‹œì‘/ë„ì°©
                const startX = Math.floor(Math.random() * gridSize);
                const startY = Math.floor(Math.random() * gridSize);
                const goalX = Math.floor(Math.random() * gridSize);
                const goalY = Math.floor(Math.random() * gridSize);
                
                player.x = startX;
                player.y = startY;
                goal.x = goalX;
                goal.y = goalY;
            } else {
                player.x = 0;
                player.y = 0;
                goal.x = gridSize - 1;
                goal.y = gridSize - 1;
            }
            
            // ì•½ê°„ì˜ ë²½ë§Œ ì¶”ê°€ (ê²½ë¡œëŠ” í•­ìƒ ì¡´ì¬)
            for (let i = 0; i < gridSize * 2; i++) {
                const x = Math.floor(Math.random() * gridSize);
                const y = Math.floor(Math.random() * gridSize);
                if ((x !== player.x || y !== player.y) && (x !== goal.x || y !== goal.y)) {
                    maze[y][x] = 1;
                }
            }
            
            // ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
            shortestPathLength = findShortestPath(player.x, player.y, goal.x, goal.y);
            if (shortestPathLength < 0) shortestPathLength = 0; // ê²½ë¡œ ì—†ìœ¼ë©´ 0
        }
        
        function drawMaze() {
            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
            let canvasSize = 500;
            if (currentLevel === 5) canvasSize = 750;
            if (currentLevel === 6) canvasSize = 735;
            if (currentLevel === 7) canvasSize = 720;
            
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            // ë°°ê²½
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ì–´ë‘  ëª¨ë“œì¸ ê²½ìš° (ë ˆë²¨ 4 ì´ìƒ) - ë‹¨, íŒíŠ¸ê°€ í™œì„±í™”ë˜ì§€ ì•Šì•˜ì„ ë•Œë§Œ
            if (currentLevel >= 4 && !hintActive) {
                // ì „ì²´ë¥¼ ì–´ë‘¡ê²Œ
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // í”Œë ˆì´ì–´ ì£¼ë³€ë§Œ ë³´ì´ê²Œ
                const visibleRange = 2;
                for (let y = Math.max(0, player.y - visibleRange); y <= Math.min(gridSize - 1, player.y + visibleRange); y++) {
                    for (let x = Math.max(0, player.x - visibleRange); x <= Math.min(gridSize - 1, player.x + visibleRange); x++) {
                        if (maze[y][x] === 1) {
                            // ë²½
                            ctx.fillStyle = '#764ba2';
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            ctx.strokeStyle = '#667eea';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        } else {
                            // ê¸¸
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            ctx.strokeStyle = '#e0e0e0';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        }
                    }
                }
                
                // ëª©í‘œê°€ ë³´ì´ëŠ” ë²”ìœ„ì— ìˆìœ¼ë©´ ê·¸ë¦¬ê¸°
                if (Math.abs(goal.x - player.x) <= visibleRange && Math.abs(goal.y - player.y) <= visibleRange) {
                    let fontSize = 18;
                    let offset = 3;
                    let yOffset = 19;
                    if (currentLevel === 5) {
                        fontSize = 20;
                        offset = 6;
                        yOffset = 21;
                    } else if (currentLevel === 6) {
                        fontSize = 18;
                        offset = 2;
                        yOffset = 17;
                    } else if (currentLevel === 7) {
                        fontSize = 15;
                        offset = 2;
                        yOffset = 15;
                    }
                    ctx.font = `${fontSize}px Arial`;
                    ctx.fillText('ğŸ§€', goal.x * cellSize + offset, goal.y * cellSize + yOffset);
                }
                
                // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
                let fontSize = 18;
                let offset = 3;
                let yOffset = 19;
                if (currentLevel === 5) {
                    fontSize = 20;
                    offset = 6;
                    yOffset = 21;
                } else if (currentLevel === 6) {
                    fontSize = 18;
                    offset = 2;
                    yOffset = 17;
                } else if (currentLevel === 7) {
                    fontSize = 15;
                    offset = 2;
                    yOffset = 15;
                }
                ctx.font = `${fontSize}px Arial`;
                ctx.fillText('ğŸ±', player.x * cellSize + offset, player.y * cellSize + yOffset);
                
            } else {
                // ì¼ë°˜ ëª¨ë“œ - ì „ì²´ ë¯¸ë¡œ ë³´ì´ê¸° (ë ˆë²¨ 3 ë˜ëŠ” íŒíŠ¸ í™œì„±í™”)
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (maze[y][x] === 1) {
                            // ë²½
                            ctx.fillStyle = '#764ba2';
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            ctx.strokeStyle = '#667eea';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        } else {
                            // ê¸¸
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            ctx.strokeStyle = '#e0e0e0';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        }
                    }
                }
                
                // ëª©í‘œ (ì¹˜ì¦ˆ) ê·¸ë¦¬ê¸°
                let fontSize = 18;
                let offset = 3;
                let yOffset = 19;
                if (currentLevel === 5) {
                    fontSize = 20;
                    offset = 6;
                    yOffset = 21;
                } else if (currentLevel === 6) {
                    fontSize = 18;
                    offset = 2;
                    yOffset = 17;
                } else if (currentLevel === 7) {
                    fontSize = 15;
                    offset = 2;
                    yOffset = 15;
                }
                ctx.font = `${fontSize}px Arial`;
                ctx.fillText('ğŸ§€', goal.x * cellSize + offset, goal.y * cellSize + yOffset);
                
                // í”Œë ˆì´ì–´ (ê³ ì–‘ì´) ê·¸ë¦¬ê¸°
                ctx.font = `${fontSize}px Arial`;
                ctx.fillText('ğŸ±', player.x * cellSize + offset, player.y * cellSize + yOffset);
            }
            
            // íŒíŠ¸ í™œì„±í™” í‘œì‹œ
            if (hintActive) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                let hintText = 'ğŸ’¡ íŒíŠ¸ í™œì„±í™”!';
                if (currentLevel === 6) hintText = 'ğŸ’¡ íŒíŠ¸ í™œì„±í™”! (2ì´ˆ)';
                if (currentLevel === 7) hintText = `ğŸ’¡ íŒíŠ¸ í™œì„±í™”! (1.5ì´ˆ, ${hintsRemaining}ë²ˆ ë‚¨ìŒ)`;
                ctx.fillText(hintText, canvas.width / 2, 30);
                ctx.textAlign = 'left';
            }
        }
        
        function updateHintButton() {
            const hintBtn = document.getElementById('hintBtn');
            if (!hintBtn) return;
            
            if (currentLevel === 7) {
                hintBtn.textContent = `ğŸ’¡ íŒíŠ¸ (${hintsRemaining}/4)`;
                if (hintsRemaining <= 0) {
                    hintBtn.disabled = true;
                    hintBtn.style.opacity = '0.5';
                }
            } else {
                hintBtn.textContent = 'ğŸ’¡ íŒíŠ¸';
                hintBtn.disabled = false;
                hintBtn.style.opacity = '1';
            }
        }
        
        function updateInfoDisplay() {
            // ìµœë‹¨ ê±°ë¦¬ í‘œì‹œ
            const pathInfo = document.getElementById('pathInfo');
            if (pathInfo && shortestPathLength > 0) {
                pathInfo.textContent = `ìµœë‹¨ ê±°ë¦¬: ${shortestPathLength}ì¹¸`;
            }
            
            // íŒíŠ¸ ì‚¬ìš© íšŸìˆ˜ í‘œì‹œ (ë ˆë²¨ 4 ì´ìƒ)
            const hintInfo = document.getElementById('hintInfo');
            if (hintInfo && currentLevel >= 4) {
                if (currentLevel === 7) {
                    hintInfo.textContent = `íŒíŠ¸ ì‚¬ìš©: ${hintsUsed}íšŒ (ë‚¨ì€ íšŸìˆ˜: ${hintsRemaining}/4)`;
                } else {
                    hintInfo.textContent = `íŒíŠ¸ ì‚¬ìš©: ${hintsUsed}íšŒ`;
                }
            } else if (hintInfo) {
                hintInfo.textContent = '';
            }
        }
        
        function useHint() {
            // ë ˆë²¨ 3ì´ê±°ë‚˜ ì´ë¯¸ íŒíŠ¸ê°€ í™œì„±í™”ë˜ì–´ ìˆê±°ë‚˜ ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ë¬´ì‹œ
            if (currentLevel < 4 || hintActive || hintCooldown) {
                if (hintCooldown) {
                    alert('íŒíŠ¸ëŠ” 10ì´ˆì— í•œ ë²ˆë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ìš”!');
                }
                return;
            }
            
            // ë ˆë²¨ 7ì—ì„œ íŒíŠ¸ íšŸìˆ˜ ì²´í¬
            if (currentLevel === 7) {
                if (hintsRemaining <= 0) {
                    alert('íŒíŠ¸ë¥¼ ëª¨ë‘ ì‚¬ìš©í–ˆì–´ìš”! ğŸ˜±');
                    return;
                }
                hintsRemaining--;
                updateHintButton();
            }
            
            // íŒíŠ¸ ì‚¬ìš© íšŸìˆ˜ ì¦ê°€
            hintsUsed++;
            updateInfoDisplay();
            
            // íŒíŠ¸ ì§€ì† ì‹œê°„ (ë ˆë²¨ 6ì€ 2ì´ˆ, ë ˆë²¨ 7ì€ 1.5ì´ˆ, ë‚˜ë¨¸ì§€ëŠ” 3ì´ˆ)
            let hintDuration = 3000;
            if (currentLevel === 6) {
                hintDuration = 2000;
            } else if (currentLevel === 7) {
                hintDuration = 1500;
            }
            
            // íŒíŠ¸ í™œì„±í™”
            hintActive = true;
            hintCooldown = true;
            const hintBtn = document.getElementById('hintBtn');
            if (currentLevel !== 7 || hintsRemaining > 0) {
                hintBtn.disabled = true;
            }
            
            drawMaze();
            
            // íŒíŠ¸ ë¹„í™œì„±í™”
            setTimeout(() => {
                hintActive = false;
                drawMaze();
            }, hintDuration);
            
            // 10ì´ˆ í›„ íŒíŠ¸ ë‹¤ì‹œ ì‚¬ìš© ê°€ëŠ¥ (ë ˆë²¨ 7ì—ì„œ íŒíŠ¸ê°€ ë‚¨ì•„ìˆì„ ë•Œë§Œ)
            setTimeout(() => {
                hintCooldown = false;
                if (currentLevel !== 7 || hintsRemaining > 0) {
                    hintBtn.disabled = false;
                }
            }, 10000);
        }
        
        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            // ê²½ê³„ ì²´í¬
            if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {
                return;
            }
            
            // ë²½ ì²´í¬
            if (maze[newY][newX] === 1) {
                return;
            }
            
            // ì´ë™
            player.x = newX;
            player.y = newY;
            moves++;
            document.getElementById('moves').textContent = moves;
            
            drawMaze();
            
            // ëª©í‘œ ë„ë‹¬ ì²´í¬
            if (player.x === goal.x && player.y === goal.y) {
                setTimeout(showCongratulations, 300);
            }
        }
        
        function showCongratulations() {
            document.getElementById('finalMoves').textContent = moves;
            
            // íŒíŠ¸ ì‚¬ìš© ì •ë³´ í‘œì‹œ
            const finalHintInfo = document.getElementById('finalHintInfo');
            if (currentLevel >= 4) {
                finalHintInfo.textContent = `íŒíŠ¸ ì‚¬ìš©: ${hintsUsed}íšŒ`;
            } else {
                finalHintInfo.textContent = '';
            }
            
            // ìµœë‹¨ ê±°ë¦¬ ì •ë³´ í‘œì‹œ
            const finalPathInfo = document.getElementById('finalPathInfo');
            if (shortestPathLength > 0) {
                const efficiency = ((shortestPathLength / moves) * 100).toFixed(1);
                finalPathInfo.textContent = `ìµœë‹¨ ê±°ë¦¬: ${shortestPathLength}ì¹¸ (íš¨ìœ¨: ${efficiency}%)`;
            } else {
                finalPathInfo.textContent = '';
            }
            
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('congratulations').style.display = 'block';
        }
        
        function hideCongratulations() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('congratulations').style.display = 'none';
        }
        
        function nextLevel() {
            hideCongratulations();
            currentLevel++;
            if (currentLevel > 7) currentLevel = 3;
            loadLevel(currentLevel);
        }
        
        function restartLevel() {
            hideCongratulations();
            loadLevel(currentLevel);
        }
        
        function loadLevel(level) {
            console.log('loadLevel called with level:', level);
            currentLevel = level;
            
            // ë¡œë”© í‘œì‹œ
            const overlay = document.getElementById('overlay');
            const loading = document.getElementById('loading');
            
            console.log('Showing loading...');
            if (overlay) overlay.style.display = 'block';
            if (loading) loading.style.display = 'block';
            
            // ë¹„ë™ê¸°ë¡œ ë¯¸ë¡œ ìƒì„± (UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡)
            setTimeout(() => {
                console.log('Starting maze generation...');
                
                // ë ˆë²¨ë³„ ë§µ í¬ê¸° ì„¤ì •
                if (level === 5) {
                    gridSize = 30;
                    cellSize = 25;
                } else if (level === 6) {
                    gridSize = 35;
                    cellSize = 21;
                } else if (level === 7) {
                    gridSize = 40;
                    cellSize = 18;
                } else {
                    gridSize = 20;
                    cellSize = 25;
                }
                
                generateMaze(); // ë§¤ë²ˆ ìƒˆë¡œìš´ ë¯¸ë¡œ ìƒì„±
                console.log('Maze generated!');
                
                moves = 0;
                hintActive = false;
                hintCooldown = false;
                hintsUsed = 0; // íŒíŠ¸ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
                
                // ë ˆë²¨ 7ì€ íŒíŠ¸ 4ë²ˆ ì œí•œ
                hintsRemaining = (level === 7) ? 4 : 999;
                updateHintButton();
                
                let levelText = level;
                if (level === 4) levelText = '4 (ì–´ë‘  ëª¨ë“œ ğŸŒ™)';
                if (level === 5) levelText = '5 (ìŠˆí¼ ë‚œì´ë„ ğŸ”¥)';
                if (level === 6) levelText = '6 (ê·¹í•œ ë‚œì´ë„ ğŸ’€)';
                if (level === 7) levelText = '7 (ë¶ˆê°€ëŠ¥ ëª¨ë“œ â˜ ï¸)';
                
                document.getElementById('level').textContent = levelText;
                document.getElementById('moves').textContent = moves;
                updateInfoDisplay(); // ìµœë‹¨ ê±°ë¦¬ ë° íŒíŠ¸ ì •ë³´ í‘œì‹œ
                drawMaze();
                
                console.log('Hiding loading...');
                // ë¡œë”© ìˆ¨ê¸°ê¸°
                if (overlay) overlay.style.display = 'none';
                if (loading) loading.style.display = 'none';
            }, 100);
        }
        
        // í„°ì¹˜/ìŠ¤ì™€ì´í”„ ì§€ì›
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        function handleDpadTouch(event, dx, dy) {
            event.preventDefault();
            movePlayer(dx, dy);
        }

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, false);

        canvas.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, false);

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 30;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // ì¢Œìš° ìŠ¤ì™€ì´í”„
                if (Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) {
                        movePlayer(1, 0); // ì˜¤ë¥¸ìª½
                    } else {
                        movePlayer(-1, 0); // ì™¼ìª½
                    }
                }
            } else {
                // ìƒí•˜ ìŠ¤ì™€ì´í”„
                if (Math.abs(deltaY) > minSwipeDistance) {
                    if (deltaY > 0) {
                        movePlayer(0, 1); // ì•„ë˜
                    } else {
                        movePlayer(0, -1); // ìœ„
                    }
                }
            }
        }

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
            }
        });
        
        // ê²Œì„ ì‹œì‘
        loadLevel(3);
    </script>
</body>
</html>